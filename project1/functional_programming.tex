% v2-acmlarge-sample.tex, dated March 6 2012
% This is a sample file for ACM large trim journals
%
% Compilation using 'acmlarge.cls' - version 1.3, Aptara Inc.
% (c) 2011 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
\documentclass[prodmode]{acmlarge}

% Metadata Information
%% \acmVolume{2}
%% \acmNumber{3}
%% \acmArticle{1}
%% \articleSeq{1}
\acmYear{2013}
\acmMonth{10}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\SetAlFnt{\algofont}
\SetAlCapFnt{\algofont}
\SetAlCapNameFnt{\algofont}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}
\renewcommand{\algorithmcfname}{ALGORITHM}

% Page heads
\markboth{J. Datko}{On the Superiority of Functional Programming}

% Title portion
\title{On the Superiority of Functional Programming}
\author{JOSHUA DATKO \affil{Drexel University}
}
% NOTE! Affiliations placed here should be for the institution where the
%       BULK of the research was done. If the author has gone to a new
%       institution, before publication, the (above) affiliation should NOT be changed.
%       The authors 'current' address may be given in the "Author's addresses:" block (below).
%       So for example, Mr. Fogarty, the bulk of the research was done at UIUC, and he is
%       currently affiliated with NASA.


\begin{document}



\maketitle


%% Notes:

% Ideas brought from functional programming: Lazy Evaluation (to
% python), lambdas,

% weakness of pure functional languages is I/O

% Head 1
\section{Introduction}

In 2011, C++ included powerful syntax into the language: the lambda
expression.  The shallow definition of a lambda expression is that it
allows anonymous functions.  However for a language to allow anonymous
functions, it must be able to accept this function as a argument to
other functions, which makes the receiving function a ``higher order
function.''  If a language can accept higher order functions, it is
possible to write a function that accepts a number $n$ and returns a
function that adds $n$ to its argument.  Such a function is trivial in
functional programming languages, whereas with iterative languages
without support for lexical closures, this simply idea can't be as
eloquently expressed.

Alonzo Church first introduced the idea of a lambda calculus in 1936.
In 1958, John McCarthy's Lisp included support for lambda functions.
Fifty-five years later, there is excitement that Java 8, the next Java
version will include support for lambda expressions.  Lambda
expressions are but one idea from functional programming that today,
popular languages are scrambling to adopt.  The reason should be
clear.  Functional programming\footnote{In this paper I'm using the
  term \emph{Functional Programming} as a style.  This style
  incorporates several programming languages like Lisp, Scheme,
  Haskell, etc\ldots  I realize that Lisp is not a pure functional
  language, however it's influence on the style and popularity of
  functional programming can not be ignored.}, the style of treating code modules as
stateless functions and minimizing side-effects, is a more powerful
and expressive paradigm.

\section{Lazy Evaluation}

Lazy Evaluation is the technique of delaying computation until
absolutely necessary.  A classic application of lazy evaluation is
shown in \cite{Abelson1996} where the concept of streams in Scheme are
discussed in length.  In an interview, Simon Peyton Jones\footnote{A
  main designer in the Haskell programming language}, Simon recalls
that lazy evaluation was a main factor in new functional language
designs\cite{Seibel2009}.  Specifically he mentions a program designed
to calculate the number $e$ to arbitrary precision.  Simon says, ``You
just got given this list and you kept hauling on elements of the list
[\ldots] So that's not something that's very obvious to do if you're
writing a C program [\ldots] it's not a natural programming paradigm
for C.''

Python's iterators support lazy evaluation.  In designing Python,
Guido van Rossum never considered Python to be heavily influenced by
functional languages\cite{Guido2009}.  But despite his dislike of the
lambda keyword, the Python community clamored for functional features.
For a non-functional language, Python shares many of its
characteristics: first-class functions, lazy evaluation, lambda
expressions, higher order functions, and an interactive interpreter.
The adoption of these features by Python reveals the demand for
the powerful and expressive syntax of functional programming.

\section{Bottom-up Design}

Functional programming encourages \emph{bottom-up programming}, which
is the practice of creating small modules, which are used by larger
modules.  To encourage this practice, functional languages support a
Read-Eval-Print-Loop (REPL) and languages that mimic this functional
behavior included an interactive interpreter.  The REPL provides an
interactive environment with immediate feedback to code.  This
paradigm is so fundamental different than the
code-compile-test-deploy-repeat cycle that it can not be overstated.
Paul Graham compares this paradigm to the revolution in painting in
the fifteenth century.  As painters discover oil-based paints, they
could now correct their mistakes on the fly whereas with
\emph{tempera}, mistakes were costly as the paint could not be blended
or over-painted\cite{Graham:1995:ACL:229872}.  The REPL is such a
powerful concept that if a language does not have one by default,
there is usually a shell replacement\cite{REPL}.

\section{Extensiblility for Parallelism}

Since functional programming encourages stateless operations,
immutable data structures are a natural result.  Thus, operations may
be easily split across independent computing units (cores or entire
CPUs).  The most famous paradigm that demonstrates this concept are
the functions \emph{Map} and \emph{Reduce}.  Map is function that
takes a function as input and applies it to a list.  Reduce is a
function that accepts a function and a list as input and recursively
applies the combination of the function to the elements of the list.
These two higher-order functions provide the cornerstone of Google's
\emph{MapReduce} framework for processing large data sets.

\section{Encroachment into Java}

Perhaps the strongest example in support of the functional programming
style is that several functional languages have been designed to use
the Java Virtual Machine (JVM), specifically Scala and Clojure.
Clojure, a Lisp dialect and Scala, a hybrid imperative-functional
language include the functional advantages of easy parallelism,
bottom-up design, and lazy evaluation.  Additionally, they benefit
from the vast existing libraries written for Java.

Scala takes a more inclusive approach than Clojure towards functional
and object oriented languages.  Dr. Martin Odersky, the creator of
Scala, ``wanted to show that the two paradigms can be unified and that
something new and powerful could result from that
combination.\cite{Tate:2010:SLS:1951955}''  Whereas Rich Hickey, the
creator of Clojure, ``wanted a predominantly functional, extensible,
dynamic language, with a solid concurrency story, for the
industry-standard platforms of the JVM [\ldots] and didn't find
one.\cite{Tate:2010:SLS:1951955}''  Both languages bring the power of
functional programming to a wide-platform by leveraging the JVM.

\section{Conclusion}

The functional programming style is superior to the imperative model.
Through lazy evaluation, computation is performed when needed allowing
for processing of infinite streams without consuming infinite
resources.  A paradigm of bottom-up design allows for rapid-prototype
and encourages modularity.  With the need for system to scale,
parallelism is critical and immutable data structures and higher order
functions enable this behavior.  The desire for functional programming
has produced hybrid languages that run the JVM.  For over fifty years,
languages have been borrowing concepts from functional languages.
Functional languages have been and will continue to be, the style of
choice among all other programming languages.
% Bibliography
\bibliographystyle{ACM-Reference-Format-Journals}
\bibliography{functional}
                                % Sample .bib file with references that match those in
                                % the 'Specifications Document (V1.5)' as well containing
                                % 'legacy' bibs and bibs with 'alternate codings'.
                                % Gerry Murray - March 2012



\end{document}
% End of v2-acmlarge-sample.tex (March 2012) - Gerry Murray, ACM
